"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("./channel");
var compositeMark = require("./compositemark");
var encoding_1 = require("./encoding");
var vlEncoding = require("./encoding");
var log = require("./log");
var mark_1 = require("./mark");
var stack_1 = require("./stack");
var util_1 = require("./util");
/* Custom type guards */
function isFacetSpec(spec) {
    return spec['facet'] !== undefined;
}
exports.isFacetSpec = isFacetSpec;
function isUnitSpec(spec) {
    return !!spec['mark'];
}
exports.isUnitSpec = isUnitSpec;
function isLayerSpec(spec) {
    return spec['layer'] !== undefined;
}
exports.isLayerSpec = isLayerSpec;
function isRepeatSpec(spec) {
    return spec['repeat'] !== undefined;
}
exports.isRepeatSpec = isRepeatSpec;
function isConcatSpec(spec) {
    return isVConcatSpec(spec) || isHConcatSpec(spec);
}
exports.isConcatSpec = isConcatSpec;
function isVConcatSpec(spec) {
    return spec['vconcat'] !== undefined;
}
exports.isVConcatSpec = isVConcatSpec;
function isHConcatSpec(spec) {
    return spec['hconcat'] !== undefined;
}
exports.isHConcatSpec = isHConcatSpec;
/**
 * Decompose extended unit specs into composition of pure unit specs.
 */
// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize
function normalize(spec, config) {
    if (isFacetSpec(spec)) {
        return normalizeFacet(spec, config);
    }
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, config);
    }
    if (isRepeatSpec(spec)) {
        return normalizeRepeat(spec, config);
    }
    if (isVConcatSpec(spec)) {
        return normalizeVConcat(spec, config);
    }
    if (isHConcatSpec(spec)) {
        return normalizeHConcat(spec, config);
    }
    if (isUnitSpec(spec)) {
        var hasRow = encoding_1.channelHasField(spec.encoding, channel_1.ROW);
        var hasColumn = encoding_1.channelHasField(spec.encoding, channel_1.COLUMN);
        if (hasRow || hasColumn) {
            return normalizeFacetedUnit(spec, config);
        }
        return normalizeNonFacetUnit(spec, config);
    }
    throw new Error(log.message.INVALID_SPEC);
}
exports.normalize = normalize;
function normalizeFacet(spec, config) {
    var subspec = spec.spec, rest = __rest(spec, ["spec"]);
    return __assign({}, rest, { 
        // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
        spec: normalize(subspec, config) });
}
function normalizeLayer(spec, config) {
    var layer = spec.layer, rest = __rest(spec, ["layer"]);
    return __assign({}, rest, { layer: layer.map(function (subspec) { return isLayerSpec(subspec) ? normalizeLayer(subspec, config) : normalizeNonFacetUnit(subspec, config); }) });
}
function normalizeRepeat(spec, config) {
    var subspec = spec.spec, rest = __rest(spec, ["spec"]);
    return __assign({}, rest, { spec: normalize(subspec, config) });
}
function normalizeVConcat(spec, config) {
    var vconcat = spec.vconcat, rest = __rest(spec, ["vconcat"]);
    return __assign({}, rest, { vconcat: vconcat.map(function (subspec) { return normalize(subspec, config); }) });
}
function normalizeHConcat(spec, config) {
    var hconcat = spec.hconcat, rest = __rest(spec, ["hconcat"]);
    return __assign({}, rest, { hconcat: hconcat.map(function (subspec) { return normalize(subspec, config); }) });
}
function normalizeFacetedUnit(spec, config) {
    // New encoding in the inside spec should not contain row / column
    // as row/column should be moved to facet
    var _a = spec.encoding, row = _a.row, column = _a.column, encoding = __rest(_a, ["row", "column"]);
    // Mark and encoding should be moved into the inner spec
    var mark = spec.mark, width = spec.width, height = spec.height, selection = spec.selection, _ = spec.encoding, outerSpec = __rest(spec, ["mark", "width", "height", "selection", "encoding"]);
    return __assign({}, outerSpec, { facet: __assign({}, (row ? { row: row } : {}), (column ? { column: column } : {})), spec: normalizeNonFacetUnit(__assign({ mark: mark }, (width ? { width: width } : {}), (height ? { height: height } : {}), { encoding: encoding }, (selection ? { selection: selection } : {})), config) });
}
function isNonFacetUnitSpecWithPrimitiveMark(spec) {
    return mark_1.isPrimitiveMark(spec.mark);
}
function normalizeNonFacetUnit(spec, config) {
    if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {
        // TODO: thoroughly test
        if (encoding_1.isRanged(spec.encoding)) {
            return normalizeRangedUnit(spec);
        }
        var overlayConfig = config && config.overlay;
        var overlayWithLine = overlayConfig && spec.mark === mark_1.AREA &&
            util_1.contains(['linepoint', 'line'], overlayConfig.area);
        var overlayWithPoint = overlayConfig && ((overlayConfig.line && spec.mark === mark_1.LINE) ||
            (overlayConfig.area === 'linepoint' && spec.mark === mark_1.AREA));
        // TODO: consider moving this to become another case of compositeMark
        if (overlayWithPoint || overlayWithLine) {
            return normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config);
        }
        return spec; // Nothing to normalize
    }
    else {
        return compositeMark.normalize(spec, config);
    }
}
function normalizeRangedUnit(spec) {
    var hasX = encoding_1.channelHasField(spec.encoding, channel_1.X);
    var hasY = encoding_1.channelHasField(spec.encoding, channel_1.Y);
    var hasX2 = encoding_1.channelHasField(spec.encoding, channel_1.X2);
    var hasY2 = encoding_1.channelHasField(spec.encoding, channel_1.Y2);
    if ((hasX2 && !hasX) || (hasY2 && !hasY)) {
        var normalizedSpec = util_1.duplicate(spec);
        if (hasX2 && !hasX) {
            normalizedSpec.encoding.x = normalizedSpec.encoding.x2;
            delete normalizedSpec.encoding.x2;
        }
        if (hasY2 && !hasY) {
            normalizedSpec.encoding.y = normalizedSpec.encoding.y2;
            delete normalizedSpec.encoding.y2;
        }
        return normalizedSpec;
    }
    return spec;
}
// FIXME(#1804): re-design this
function normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config) {
    var mark = spec.mark, selection = spec.selection, encoding = spec.encoding, outerSpec = __rest(spec, ["mark", "selection", "encoding"]);
    var layer = [{ mark: mark, encoding: encoding }];
    // Need to copy stack config to overlayed layer
    var stackProps = stack_1.stack(mark, encoding, config ? config.stack : undefined);
    var overlayEncoding = encoding;
    if (stackProps) {
        var stackFieldChannel = stackProps.fieldChannel, offset = stackProps.offset;
        overlayEncoding = __assign({}, encoding, (_a = {}, _a[stackFieldChannel] = __assign({}, encoding[stackFieldChannel], (offset ? { stack: offset } : {})), _a));
    }
    if (overlayWithLine) {
        layer.push(__assign({ mark: {
                type: 'line',
                style: 'lineOverlay'
            } }, (selection ? { selection: selection } : {}), { encoding: overlayEncoding }));
    }
    if (overlayWithPoint) {
        layer.push(__assign({ mark: {
                type: 'point',
                filled: true,
                style: 'pointOverlay'
            } }, (selection ? { selection: selection } : {}), { encoding: overlayEncoding }));
    }
    return __assign({}, outerSpec, { layer: layer });
    var _a;
}
// TODO: add vl.spec.validate & move stuff from vl.validate to here
/* Accumulate non-duplicate fieldDefs in a dictionary */
function accumulate(dict, fieldDefs) {
    fieldDefs.forEach(function (fieldDef) {
        // Consider only pure fieldDef properties (ignoring scale, axis, legend)
        var pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce(function (f, key) {
            if (fieldDef[key] !== undefined) {
                f[key] = fieldDef[key];
            }
            return f;
        }, {});
        var key = util_1.hash(pureFieldDef);
        dict[key] = dict[key] || fieldDef;
    });
    return dict;
}
/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */
function fieldDefIndex(spec, dict) {
    if (dict === void 0) { dict = {}; }
    // FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat
    if (isLayerSpec(spec)) {
        spec.layer.forEach(function (layer) {
            if (isUnitSpec(layer)) {
                accumulate(dict, vlEncoding.fieldDefs(layer.encoding));
            }
            else {
                fieldDefIndex(layer, dict);
            }
        });
    }
    else if (isFacetSpec(spec)) {
        accumulate(dict, vlEncoding.fieldDefs(spec.facet));
        fieldDefIndex(spec.spec, dict);
    }
    else if (isRepeatSpec(spec)) {
        fieldDefIndex(spec.spec, dict);
    }
    else if (isConcatSpec(spec)) {
        var childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;
        childSpec.forEach(function (child) { return fieldDefIndex(child, dict); });
    }
    else {
        accumulate(dict, vlEncoding.fieldDefs(spec.encoding));
    }
    return dict;
}
/* Returns all non-duplicate fieldDefs in a spec in a flat array */
function fieldDefs(spec) {
    return util_1.vals(fieldDefIndex(spec));
}
exports.fieldDefs = fieldDefs;
function isStacked(spec, config) {
    config = config || spec.config;
    if (mark_1.isPrimitiveMark(spec.mark)) {
        return stack_1.stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;
    }
    return false;
}
exports.isStacked = isStacked;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQ0FBb0Q7QUFDcEQsK0NBQWlEO0FBR2pELHVDQUFrRjtBQUNsRix1Q0FBeUM7QUFHekMsMkJBQTZCO0FBQzdCLCtCQUEyRTtBQUkzRSxpQ0FBOEI7QUFJOUIsK0JBQTZEO0FBOEw3RCx3QkFBd0I7QUFHeEIscUJBQTRCLElBQTRDO0lBQ3RFLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ3JDLENBQUM7QUFGRCxrQ0FFQztBQUVELG9CQUEyQixJQUE0QztJQUNyRSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QixDQUFDO0FBRkQsZ0NBRUM7QUFFRCxxQkFBNEIsSUFBNEM7SUFDdEUsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDckMsQ0FBQztBQUZELGtDQUVDO0FBRUQsc0JBQTZCLElBQTRDO0lBQ3ZFLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ3RDLENBQUM7QUFGRCxvQ0FFQztBQUVELHNCQUE2QixJQUE0QztJQUN2RSxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRkQsb0NBRUM7QUFFRCx1QkFBOEIsSUFBNEM7SUFDeEUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDdkMsQ0FBQztBQUZELHNDQUVDO0FBRUQsdUJBQThCLElBQTRDO0lBQ3hFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ3ZDLENBQUM7QUFGRCxzQ0FFQztBQUVEOztHQUVH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QUksQ0FBQyxPQUFPLENBQUM7UUFDcEUsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQTFCLENBQTBCLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixVQUFVLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsbUVBQW1FO0FBQ25FLG1CQUEwQixJQUE0QztJQUNwRSxNQUFNLENBQUMsV0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCw4QkFFQztBQUVELG1CQUEwQixJQUF3QyxFQUFFLE1BQWU7SUFDakYsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQy9CLEVBQUUsQ0FBQyxDQUFDLHNCQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQixNQUFNLENBQUMsYUFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFDN0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQ2xDLEtBQUssSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQVJELDhCQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDT0xVTU4sIFJPVywgWCwgWDIsIFksIFkyfSBmcm9tICcuL2NoYW5uZWwnO1xuaW1wb3J0ICogYXMgY29tcG9zaXRlTWFyayBmcm9tICcuL2NvbXBvc2l0ZW1hcmsnO1xuaW1wb3J0IHtDb25maWcsIE92ZXJsYXlDb25maWd9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7RGF0YX0gZnJvbSAnLi9kYXRhJztcbmltcG9ydCB7Y2hhbm5lbEhhc0ZpZWxkLCBFbmNvZGluZywgRW5jb2RpbmdXaXRoRmFjZXQsIGlzUmFuZ2VkfSBmcm9tICcuL2VuY29kaW5nJztcbmltcG9ydCAqIGFzIHZsRW5jb2RpbmcgZnJvbSAnLi9lbmNvZGluZyc7XG5pbXBvcnQge0ZhY2V0TWFwcGluZ30gZnJvbSAnLi9mYWNldCc7XG5pbXBvcnQge0ZpZWxkLCBGaWVsZERlZiwgUmVwZWF0UmVmfSBmcm9tICcuL2ZpZWxkZGVmJztcbmltcG9ydCAqIGFzIGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQge0FueU1hcmssIEFSRUEsIGlzUHJpbWl0aXZlTWFyaywgTElORSwgTWFyaywgTWFya0RlZn0gZnJvbSAnLi9tYXJrJztcbmltcG9ydCB7UmVwZWF0fSBmcm9tICcuL3JlcGVhdCc7XG5pbXBvcnQge1Jlc29sdmV9IGZyb20gJy4vcmVzb2x2ZSc7XG5pbXBvcnQge1NlbGVjdGlvbkRlZn0gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0IHtzdGFja30gZnJvbSAnLi9zdGFjayc7XG5pbXBvcnQge1RpdGxlUGFyYW1zfSBmcm9tICcuL3RpdGxlJztcbmltcG9ydCB7VG9wTGV2ZWxQcm9wZXJ0aWVzfSBmcm9tICcuL3RvcGxldmVscHJvcHMnO1xuaW1wb3J0IHtUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB7Y29udGFpbnMsIERpY3QsIGR1cGxpY2F0ZSwgaGFzaCwgdmFsc30gZnJvbSAnLi91dGlsJztcblxuXG5leHBvcnQgdHlwZSBUb3BMZXZlbDxTIGV4dGVuZHMgQmFzZVNwZWM+ID0gUyAmIFRvcExldmVsUHJvcGVydGllcyAmIHtcbiAgLyoqXG4gICAqIFVSTCB0byBbSlNPTiBzY2hlbWFdKGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvKSBmb3IgYSBWZWdhLUxpdGUgc3BlY2lmaWNhdGlvbi4gVW5sZXNzIHlvdSBoYXZlIGEgcmVhc29uIHRvIGNoYW5nZSB0aGlzLCB1c2UgYGh0dHBzOi8vdmVnYS5naXRodWIuaW8vc2NoZW1hL3ZlZ2EtbGl0ZS92Mi5qc29uYC4gU2V0dGluZyB0aGUgYCRzY2hlbWFgIHByb3BlcnR5IGFsbG93cyBhdXRvbWF0aWMgdmFsaWRhdGlvbiBhbmQgYXV0b2NvbXBsZXRlIGluIGVkaXRvcnMgdGhhdCBzdXBwb3J0IEpTT04gc2NoZW1hLlxuICAgKiBAZm9ybWF0IHVyaVxuICAgKi9cbiAgJHNjaGVtYT86IHN0cmluZztcblxuICAvKipcbiAgICogVmVnYS1MaXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiAgVGhpcyBwcm9wZXJ0eSBjYW4gb25seSBiZSBkZWZpbmVkIGF0IHRoZSB0b3AtbGV2ZWwgb2YgYSBzcGVjaWZpY2F0aW9uLlxuICAgKi9cbiAgY29uZmlnPzogQ29uZmlnO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlU3BlYyB7XG4gIC8qKlxuICAgKiBUaXRsZSBmb3IgdGhlIHBsb3QuXG4gICAqL1xuICB0aXRsZT86IHN0cmluZyB8IFRpdGxlUGFyYW1zO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB2aXN1YWxpemF0aW9uIGZvciBsYXRlciByZWZlcmVuY2UuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBvZiB0aGlzIG1hcmsgZm9yIGNvbW1lbnRpbmcgcHVycG9zZS5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgZGF0YSBzb3VyY2VcbiAgICovXG4gIGRhdGE/OiBEYXRhO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBkYXRhIHRyYW5zZm9ybWF0aW9ucyBzdWNoIGFzIGZpbHRlciBhbmQgbmV3IGZpZWxkIGNhbGN1bGF0aW9uLlxuICAgKi9cbiAgdHJhbnNmb3JtPzogVHJhbnNmb3JtW107XG59XG5cbi8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlcy8yNTAzKTogTWFrZSB0aGlzIGdlbmVyaWMgc28gd2UgY2FuIHN1cHBvcnQgc29tZSBmb3JtIG9mIHRvcC1kb3duIHNpemluZy5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0U2l6ZU1peGlucyB7XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgYSB2aXN1YWxpemF0aW9uLlxuICAgKlxuICAgKiBfX0RlZmF1bHQgdmFsdWU6X18gVGhpcyB3aWxsIGJlIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICpcbiAgICogLSBJZiBhIHZpZXcncyBbYGF1dG9zaXplYF0oc2l6ZS5odG1sI2F1dG9zaXplKSB0eXBlIGlzIGBcImZpdFwiYCBvciBpdHMgeC1jaGFubmVsIGhhcyBhIFtjb250aW51b3VzIHNjYWxlXShzY2FsZS5odG1sI2NvbnRpbnVvdXMpLCB0aGUgd2lkdGggd2lsbCBiZSB0aGUgdmFsdWUgb2YgW2Bjb25maWcudmlldy53aWR0aGBdKHNwZWMuaHRtbCNjb25maWcpLlxuICAgKiAtIEZvciB4LWF4aXMgd2l0aCBhIGJhbmQgb3IgcG9pbnQgc2NhbGU6IGlmIFtgcmFuZ2VTdGVwYF0oc2NhbGUuaHRtbCNiYW5kKSBpcyBhIG51bWVyaWMgdmFsdWUgb3IgdW5zcGVjaWZpZWQsIHRoZSB3aWR0aCBpcyBbZGV0ZXJtaW5lZCBieSB0aGUgcmFuZ2Ugc3RlcCwgcGFkZGluZ3MsIGFuZCB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIGZpZWxkIG1hcHBlZCB0byB4LWNoYW5uZWxdKHNjYWxlLmh0bWwjYmFuZCkuICAgT3RoZXJ3aXNlLCBpZiB0aGUgYHJhbmdlU3RlcGAgaXMgYG51bGxgLCB0aGUgd2lkdGggd2lsbCBiZSB0aGUgdmFsdWUgb2YgW2Bjb25maWcudmlldy53aWR0aGBdKHNwZWMuaHRtbCNjb25maWcpLlxuICAgKiAtIElmIG5vIGZpZWxkIGlzIG1hcHBlZCB0byBgeGAgY2hhbm5lbCwgdGhlIGB3aWR0aGAgd2lsbCBiZSB0aGUgdmFsdWUgb2YgW2Bjb25maWcuc2NhbGUudGV4dFhSYW5nZVN0ZXBgXShzaXplLmh0bWwjZGVmYXVsdC13aWR0aC1hbmQtaGVpZ2h0KSBmb3IgYHRleHRgIG1hcmsgYW5kIHRoZSB2YWx1ZSBvZiBgcmFuZ2VTdGVwYCBmb3Igb3RoZXIgbWFya3MuXG4gICAqXG4gICAqIF9fTm90ZTpfXyBGb3IgcGxvdHMgd2l0aCBbYHJvd2AgYW5kIGBjb2x1bW5gIGNoYW5uZWxzXShlbmNvZGluZy5odG1sI2ZhY2V0KSwgdGhpcyByZXByZXNlbnRzIHRoZSB3aWR0aCBvZiBhIHNpbmdsZSB2aWV3LlxuICAgKlxuICAgKiBfX1NlZSBhbHNvOl9fIFRoZSBkb2N1bWVudGF0aW9uIGZvciBbd2lkdGggYW5kIGhlaWdodF0oc2l6ZS5odG1sKSBjb250YWlucyBtb3JlIGV4YW1wbGVzLlxuICAgKi9cbiAgd2lkdGg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgYSB2aXN1YWxpemF0aW9uLlxuICAgKlxuICAgKiBfX0RlZmF1bHQgdmFsdWU6X19cbiAgICogLSBJZiBhIHZpZXcncyBbYGF1dG9zaXplYF0oc2l6ZS5odG1sI2F1dG9zaXplKSB0eXBlIGlzIGBcImZpdFwiYCBvciBpdHMgeS1jaGFubmVsIGhhcyBhIFtjb250aW51b3VzIHNjYWxlXShzY2FsZS5odG1sI2NvbnRpbnVvdXMpLCB0aGUgaGVpZ2h0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIFtgY29uZmlnLnZpZXcuaGVpZ2h0YF0oc3BlYy5odG1sI2NvbmZpZykuXG4gICAqIC0gRm9yIHktYXhpcyB3aXRoIGEgYmFuZCBvciBwb2ludCBzY2FsZTogaWYgW2ByYW5nZVN0ZXBgXShzY2FsZS5odG1sI2JhbmQpIGlzIGEgbnVtZXJpYyB2YWx1ZSBvciB1bnNwZWNpZmllZCwgdGhlIGhlaWdodCBpcyBbZGV0ZXJtaW5lZCBieSB0aGUgcmFuZ2Ugc3RlcCwgcGFkZGluZ3MsIGFuZCB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIGZpZWxkIG1hcHBlZCB0byB5LWNoYW5uZWxdKHNjYWxlLmh0bWwjYmFuZCkuIE90aGVyd2lzZSwgaWYgdGhlIGByYW5nZVN0ZXBgIGlzIGBudWxsYCwgdGhlIGhlaWdodCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBbYGNvbmZpZy52aWV3LmhlaWdodGBdKHNwZWMuaHRtbCNjb25maWcpLlxuICAgKiAtIElmIG5vIGZpZWxkIGlzIG1hcHBlZCB0byBgeWAgY2hhbm5lbCwgdGhlIGBoZWlnaHRgIHdpbGwgYmUgdGhlIHZhbHVlIG9mIGByYW5nZVN0ZXBgLlxuICAgKlxuICAgKiBfX05vdGVfXzogRm9yIHBsb3RzIHdpdGggW2Byb3dgIGFuZCBgY29sdW1uYCBjaGFubmVsc10oZW5jb2RpbmcuaHRtbCNmYWNldCksIHRoaXMgcmVwcmVzZW50cyB0aGUgaGVpZ2h0IG9mIGEgc2luZ2xlIHZpZXcuXG4gICAqXG4gICAqIF9fU2VlIGFsc286X18gVGhlIGRvY3VtZW50YXRpb24gZm9yIFt3aWR0aCBhbmQgaGVpZ2h0XShzaXplLmh0bWwpIGNvbnRhaW5zIG1vcmUgZXhhbXBsZXMuXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJpY1VuaXRTcGVjPEUgZXh0ZW5kcyBFbmNvZGluZzxhbnk+LCBNPiBleHRlbmRzIEJhc2VTcGVjLCBMYXlvdXRTaXplTWl4aW5zIHtcblxuICAvKipcbiAgICogQSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgbWFyayB0eXBlIChvbmUgb2YgYFwiYmFyXCJgLCBgXCJjaXJjbGVcImAsIGBcInNxdWFyZVwiYCwgYFwidGlja1wiYCwgYFwibGluZVwiYCxcbiAgICogYFwiYXJlYVwiYCwgYFwicG9pbnRcImAsIGBcInJ1bGVcImAsIGFuZCBgXCJ0ZXh0XCJgKSBvciBhIFttYXJrIGRlZmluaXRpb24gb2JqZWN0XShtYXJrLmh0bWwjbWFyay1kZWYpLlxuICAgKi9cbiAgbWFyazogTTtcblxuICAvKipcbiAgICogQSBrZXktdmFsdWUgbWFwcGluZyBiZXR3ZWVuIGVuY29kaW5nIGNoYW5uZWxzIGFuZCBkZWZpbml0aW9uIG9mIGZpZWxkcy5cbiAgICovXG4gIGVuY29kaW5nOiBFO1xuXG4gIC8qKlxuICAgKiBBIGtleS12YWx1ZSBtYXBwaW5nIGJldHdlZW4gc2VsZWN0aW9uIG5hbWVzIGFuZCBkZWZpbml0aW9ucy5cbiAgICovXG4gIHNlbGVjdGlvbj86IHtbbmFtZTogc3RyaW5nXTogU2VsZWN0aW9uRGVmfTtcbn1cblxuZXhwb3J0IHR5cGUgVW5pdFNwZWMgPSBHZW5lcmljVW5pdFNwZWM8RW5jb2Rpbmc8c3RyaW5nIHwgUmVwZWF0UmVmPiwgTWFyayB8IE1hcmtEZWY+O1xuXG4vKipcbiAqIFVuaXQgc3BlYyB0aGF0IGNhbiBoYXZlIGEgY29tcG9zaXRlIG1hcmsuXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBvc2l0ZVVuaXRTcGVjID0gR2VuZXJpY1VuaXRTcGVjPEVuY29kaW5nPHN0cmluZyB8IFJlcGVhdFJlZj4sIEFueU1hcms+O1xuXG4vKipcbiAqIFVuaXQgc3BlYyB0aGF0IGNhbiBoYXZlIGEgY29tcG9zaXRlIG1hcmsgYW5kIHJvdyBvciBjb2x1bW4gY2hhbm5lbHMuXG4gKi9cbmV4cG9ydCB0eXBlIEZhY2V0ZWRDb21wb3NpdGVVbml0U3BlYyA9IEdlbmVyaWNVbml0U3BlYzxFbmNvZGluZ1dpdGhGYWNldDxzdHJpbmcgfCBSZXBlYXRSZWY+LCBBbnlNYXJrPjtcblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljTGF5ZXJTcGVjPFUgZXh0ZW5kcyBHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+PiBleHRlbmRzIEJhc2VTcGVjLCBMYXlvdXRTaXplTWl4aW5zIHtcbiAgLyoqXG4gICAqIExheWVyIG9yIHNpbmdsZSB2aWV3IHNwZWNpZmljYXRpb25zIHRvIGJlIGxheWVyZWQuXG4gICAqXG4gICAqIF9fTm90ZV9fOiBTcGVjaWZpY2F0aW9ucyBpbnNpZGUgYGxheWVyYCBjYW5ub3QgdXNlIGByb3dgIGFuZCBgY29sdW1uYCBjaGFubmVscyBhcyBsYXllcmluZyBmYWNldCBzcGVjaWZpY2F0aW9ucyBpcyBub3QgYWxsb3dlZC5cbiAgICovXG4gIGxheWVyOiAoR2VuZXJpY0xheWVyU3BlYzxVPiB8IFUpW107XG5cbiAgLyoqXG4gICAqIFNjYWxlLCBheGlzLCBhbmQgbGVnZW5kIHJlc29sdXRpb25zIGZvciBsYXllcnMuXG4gICAqL1xuICByZXNvbHZlPzogUmVzb2x2ZTtcbn1cblxuZXhwb3J0IHR5cGUgTGF5ZXJTcGVjID0gR2VuZXJpY0xheWVyU3BlYzxVbml0U3BlYz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJpY0ZhY2V0U3BlYzxVIGV4dGVuZHMgR2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4gZXh0ZW5kcyBCYXNlU3BlYyB7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgbWFwcGluZ3MgYmV0d2VlbiBgcm93YCBhbmQgYGNvbHVtbmAgY2hhbm5lbHMgYW5kIHRoZWlyIGZpZWxkIGRlZmluaXRpb25zLlxuICAgKi9cbiAgZmFjZXQ6IEZhY2V0TWFwcGluZzxzdHJpbmcgfCBSZXBlYXRSZWY+O1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpZmljYXRpb24gb2YgdGhlIHZpZXcgdGhhdCBnZXRzIGZhY2V0ZWQuXG4gICAqL1xuICBzcGVjOiBHZW5lcmljTGF5ZXJTcGVjPFU+IHwgVTtcbiAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIHdpdGggR2VuZXJpY1NwZWM8VT4gb25jZSB3ZSBzdXBwb3J0IGFsbCBjYXNlcztcblxuICAvKipcbiAgICogU2NhbGUsIGF4aXMsIGFuZCBsZWdlbmQgcmVzb2x1dGlvbnMgZm9yIGZhY2V0cy5cbiAgICovXG4gIHJlc29sdmU/OiBSZXNvbHZlO1xufVxuXG5leHBvcnQgdHlwZSBGYWNldFNwZWMgPSBHZW5lcmljRmFjZXRTcGVjPFVuaXRTcGVjPjtcblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljUmVwZWF0U3BlYzxVIGV4dGVuZHMgR2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4gZXh0ZW5kcyBCYXNlU3BlYyB7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgd2hhdCBmaWVsZHMgc2hvdWxkIGJlIHJlcGVhdGVkIGludG8gdmlld3MgdGhhdCBhcmUgbGFpZCBvdXQgYXMgYSBgcm93YCBvciBgY29sdW1uYC5cbiAgICovXG4gIHJlcGVhdDogUmVwZWF0O1xuXG4gIHNwZWM6IEdlbmVyaWNTcGVjPFU+O1xuXG4gIC8qKlxuICAgKiBTY2FsZSBhbmQgbGVnZW5kIHJlc29sdXRpb25zIGZvciByZXBlYXRlZCBjaGFydHMuXG4gICAqL1xuICByZXNvbHZlPzogUmVzb2x2ZTtcbn1cblxuZXhwb3J0IHR5cGUgUmVwZWF0U3BlYyA9IEdlbmVyaWNSZXBlYXRTcGVjPFVuaXRTcGVjPjtcblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljVkNvbmNhdFNwZWM8VSBleHRlbmRzIEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+IGV4dGVuZHMgQmFzZVNwZWMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHZpZXdzIHRoYXQgc2hvdWxkIGJlIGNvbmNhdGVuYXRlZCBhbmQgcHV0IGludG8gYSBjb2x1bW4uXG4gICAqL1xuICB2Y29uY2F0OiAoR2VuZXJpY1NwZWM8VT4pW107XG5cbiAgLyoqXG4gICAqIFNjYWxlLCBheGlzLCBhbmQgbGVnZW5kIHJlc29sdXRpb25zIGZvciB2ZXJ0aWNhbGx5IGNvbmNhdGVuYXRlZCBjaGFydHMuXG4gICAqL1xuICByZXNvbHZlPzogUmVzb2x2ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmljSENvbmNhdFNwZWM8VSBleHRlbmRzIEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+IGV4dGVuZHMgQmFzZVNwZWMge1xuICAvKipcbiAgICogQSBsaXN0IG9mIHZpZXdzIHRoYXQgc2hvdWxkIGJlIGNvbmNhdGVuYXRlZCBhbmQgcHV0IGludG8gYSByb3cuXG4gICAqL1xuICBoY29uY2F0OiAoR2VuZXJpY1NwZWM8VT4pW107XG5cbiAgLyoqXG4gICAqIFNjYWxlLCBheGlzLCBhbmQgbGVnZW5kIHJlc29sdXRpb25zIGZvciBob3Jpem9udGFsbHkgY29uY2F0ZW5hdGVkIGNoYXJ0cy5cbiAgICovXG4gIHJlc29sdmU/OiBSZXNvbHZlO1xufVxuXG5leHBvcnQgdHlwZSBDb25jYXRTcGVjID0gR2VuZXJpY1ZDb25jYXRTcGVjPFVuaXRTcGVjPiB8IEdlbmVyaWNIQ29uY2F0U3BlYzxVbml0U3BlYz47XG5cbmV4cG9ydCB0eXBlIEdlbmVyaWNTcGVjPFUgZXh0ZW5kcyBHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+PiA9IFUgfCBHZW5lcmljTGF5ZXJTcGVjPFU+IHwgR2VuZXJpY0ZhY2V0U3BlYzxVPiB8IEdlbmVyaWNSZXBlYXRTcGVjPFU+IHwgR2VuZXJpY1ZDb25jYXRTcGVjPFU+IHwgR2VuZXJpY0hDb25jYXRTcGVjPFU+O1xuXG5leHBvcnQgdHlwZSBTcGVjID0gR2VuZXJpY1NwZWM8VW5pdFNwZWM+O1xuXG5leHBvcnQgdHlwZSBUb3BMZXZlbEV4dGVuZGVkU3BlYyA9IFRvcExldmVsPEZhY2V0ZWRDb21wb3NpdGVVbml0U3BlYz4gfCBUb3BMZXZlbDxHZW5lcmljTGF5ZXJTcGVjPENvbXBvc2l0ZVVuaXRTcGVjPj4gfCBUb3BMZXZlbDxHZW5lcmljRmFjZXRTcGVjPENvbXBvc2l0ZVVuaXRTcGVjPj4gfCBUb3BMZXZlbDxHZW5lcmljUmVwZWF0U3BlYzxDb21wb3NpdGVVbml0U3BlYz4+IHwgVG9wTGV2ZWw8R2VuZXJpY1ZDb25jYXRTcGVjPENvbXBvc2l0ZVVuaXRTcGVjPj4gfCBUb3BMZXZlbDxHZW5lcmljSENvbmNhdFNwZWM8Q29tcG9zaXRlVW5pdFNwZWM+PjtcblxuLyogQ3VzdG9tIHR5cGUgZ3VhcmRzICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmFjZXRTcGVjKHNwZWM6IEdlbmVyaWNTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+KTogc3BlYyBpcyBHZW5lcmljRmFjZXRTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+IHtcbiAgcmV0dXJuIHNwZWNbJ2ZhY2V0J10gIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5pdFNwZWMoc3BlYzogR2VuZXJpY1NwZWM8R2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4pOiBzcGVjIGlzIEZhY2V0ZWRDb21wb3NpdGVVbml0U3BlYyB8IFVuaXRTcGVjIHtcbiAgcmV0dXJuICEhc3BlY1snbWFyayddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMYXllclNwZWMoc3BlYzogR2VuZXJpY1NwZWM8R2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4pOiBzcGVjIGlzIEdlbmVyaWNMYXllclNwZWM8R2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4ge1xuICByZXR1cm4gc3BlY1snbGF5ZXInXSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXBlYXRTcGVjKHNwZWM6IEdlbmVyaWNTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+KTogc3BlYyBpcyBHZW5lcmljUmVwZWF0U3BlYzxHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+PiB7XG4gIHJldHVybiBzcGVjWydyZXBlYXQnXSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb25jYXRTcGVjKHNwZWM6IEdlbmVyaWNTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+KTogc3BlYyBpcyBHZW5lcmljVkNvbmNhdFNwZWM8R2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4gfCBHZW5lcmljSENvbmNhdFNwZWM8R2VuZXJpY1VuaXRTcGVjPGFueSwgYW55Pj4ge1xuICByZXR1cm4gaXNWQ29uY2F0U3BlYyhzcGVjKSB8fCBpc0hDb25jYXRTcGVjKHNwZWMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWQ29uY2F0U3BlYyhzcGVjOiBHZW5lcmljU3BlYzxHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+Pik6IHNwZWMgaXMgR2VuZXJpY1ZDb25jYXRTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+IHtcbiAgcmV0dXJuIHNwZWNbJ3Zjb25jYXQnXSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIQ29uY2F0U3BlYyhzcGVjOiBHZW5lcmljU3BlYzxHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+Pik6IHNwZWMgaXMgR2VuZXJpY0hDb25jYXRTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+IHtcbiAgcmV0dXJuIHNwZWNbJ2hjb25jYXQnXSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERlY29tcG9zZSBleHRlbmRlZCB1bml0IHNwZWNzIGludG8gY29tcG9zaXRpb24gb2YgcHVyZSB1bml0IHNwZWNzLlxuICovXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdGhpcyB0byBhbm90aGVyIGZpbGUuICBNYXliZSB2bC5zcGVjLm5vcm1hbGl6ZSBvciB2bC5ub3JtYWxpemVcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoc3BlYzogVG9wTGV2ZWxFeHRlbmRlZFNwZWMsIGNvbmZpZzogQ29uZmlnKTogU3BlYyB7XG4gIGlmIChpc0ZhY2V0U3BlYyhzcGVjKSkge1xuICAgIHJldHVybiBub3JtYWxpemVGYWNldChzcGVjLCBjb25maWcpO1xuICB9XG4gIGlmIChpc0xheWVyU3BlYyhzcGVjKSkge1xuICAgIHJldHVybiBub3JtYWxpemVMYXllcihzcGVjLCBjb25maWcpO1xuICB9XG4gIGlmIChpc1JlcGVhdFNwZWMoc3BlYykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0KHNwZWMsIGNvbmZpZyk7XG4gIH1cbiAgaWYgKGlzVkNvbmNhdFNwZWMoc3BlYykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVkNvbmNhdChzcGVjLCBjb25maWcpO1xuICB9XG4gIGlmIChpc0hDb25jYXRTcGVjKHNwZWMpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUhDb25jYXQoc3BlYywgY29uZmlnKTtcbiAgfVxuICBpZiAoaXNVbml0U3BlYyhzcGVjKSkge1xuICAgIGNvbnN0IGhhc1JvdyA9IGNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBST1cpO1xuICAgIGNvbnN0IGhhc0NvbHVtbiA9IGNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBDT0xVTU4pO1xuXG4gICAgaWYgKGhhc1JvdyB8fCBoYXNDb2x1bW4pIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVGYWNldGVkVW5pdChzcGVjLCBjb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplTm9uRmFjZXRVbml0KHNwZWMsIGNvbmZpZyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFMSURfU1BFQyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZhY2V0KHNwZWM6IEdlbmVyaWNGYWNldFNwZWM8Q29tcG9zaXRlVW5pdFNwZWM+LCBjb25maWc6IENvbmZpZyk6IEZhY2V0U3BlYyB7XG4gIGNvbnN0IHtzcGVjOiBzdWJzcGVjLCAuLi5yZXN0fSA9IHNwZWM7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICAvLyBUT0RPOiByZW1vdmUgXCJhbnlcIiBvbmNlIHdlIHN1cHBvcnQgYWxsIGZhY2V0IGxpc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzI3NjBcbiAgICBzcGVjOiBub3JtYWxpemUoc3Vic3BlYywgY29uZmlnKSBhcyBhbnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTGF5ZXIoc3BlYzogR2VuZXJpY0xheWVyU3BlYzxDb21wb3NpdGVVbml0U3BlYz4sIGNvbmZpZzogQ29uZmlnKTogTGF5ZXJTcGVjIHtcbiAgY29uc3Qge2xheWVyOiBsYXllciwgLi4ucmVzdH0gPSBzcGVjO1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgbGF5ZXI6IGxheWVyLm1hcCgoc3Vic3BlYykgPT4gaXNMYXllclNwZWMoc3Vic3BlYykgPyBub3JtYWxpemVMYXllcihzdWJzcGVjLCBjb25maWcpIDogbm9ybWFsaXplTm9uRmFjZXRVbml0KHN1YnNwZWMsIGNvbmZpZykpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdChzcGVjOiBHZW5lcmljUmVwZWF0U3BlYzxDb21wb3NpdGVVbml0U3BlYz4sIGNvbmZpZzogQ29uZmlnKTogUmVwZWF0U3BlYyB7XG4gIGNvbnN0IHtzcGVjOiBzdWJzcGVjLCAuLi5yZXN0fSA9IHNwZWM7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBzcGVjOiBub3JtYWxpemUoc3Vic3BlYywgY29uZmlnKVxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWQ29uY2F0KHNwZWM6IEdlbmVyaWNWQ29uY2F0U3BlYzxDb21wb3NpdGVVbml0U3BlYz4sIGNvbmZpZzogQ29uZmlnKTogQ29uY2F0U3BlYyB7XG4gIGNvbnN0IHt2Y29uY2F0OiB2Y29uY2F0LCAuLi5yZXN0fSA9IHNwZWM7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICB2Y29uY2F0OiB2Y29uY2F0Lm1hcCgoc3Vic3BlYykgPT4gbm9ybWFsaXplKHN1YnNwZWMsIGNvbmZpZykpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhDb25jYXQoc3BlYzogR2VuZXJpY0hDb25jYXRTcGVjPENvbXBvc2l0ZVVuaXRTcGVjPiwgY29uZmlnOiBDb25maWcpOiBDb25jYXRTcGVjIHtcbiAgY29uc3Qge2hjb25jYXQ6IGhjb25jYXQsIC4uLnJlc3R9ID0gc3BlYztcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGhjb25jYXQ6IGhjb25jYXQubWFwKChzdWJzcGVjKSA9PiBub3JtYWxpemUoc3Vic3BlYywgY29uZmlnKSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRmFjZXRlZFVuaXQoc3BlYzogRmFjZXRlZENvbXBvc2l0ZVVuaXRTcGVjLCBjb25maWc6IENvbmZpZyk6IEZhY2V0U3BlYyB7XG4gIC8vIE5ldyBlbmNvZGluZyBpbiB0aGUgaW5zaWRlIHNwZWMgc2hvdWxkIG5vdCBjb250YWluIHJvdyAvIGNvbHVtblxuICAvLyBhcyByb3cvY29sdW1uIHNob3VsZCBiZSBtb3ZlZCB0byBmYWNldFxuICBjb25zdCB7cm93OiByb3csIGNvbHVtbjogY29sdW1uLCAuLi5lbmNvZGluZ30gPSBzcGVjLmVuY29kaW5nO1xuXG4gIC8vIE1hcmsgYW5kIGVuY29kaW5nIHNob3VsZCBiZSBtb3ZlZCBpbnRvIHRoZSBpbm5lciBzcGVjXG4gIGNvbnN0IHttYXJrLCB3aWR0aCwgaGVpZ2h0LCBzZWxlY3Rpb24sIGVuY29kaW5nOiBfLCAuLi5vdXRlclNwZWN9ID0gc3BlYztcblxuICByZXR1cm4ge1xuICAgIC4uLm91dGVyU3BlYyxcbiAgICBmYWNldDoge1xuICAgICAgLi4uKHJvdyA/IHtyb3d9IDoge30pLFxuICAgICAgLi4uKGNvbHVtbiA/IHtjb2x1bW59OiB7fSksXG4gICAgfSxcbiAgICBzcGVjOiBub3JtYWxpemVOb25GYWNldFVuaXQoe1xuICAgICAgbWFyayxcbiAgICAgIC4uLih3aWR0aCA/IHt3aWR0aH0gOiB7fSksXG4gICAgICAuLi4oaGVpZ2h0ID8ge2hlaWdodH0gOiB7fSksXG4gICAgICBlbmNvZGluZyxcbiAgICAgIC4uLihzZWxlY3Rpb24gPyB7c2VsZWN0aW9ufSA6IHt9KVxuICAgIH0sIGNvbmZpZylcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb25GYWNldFVuaXRTcGVjV2l0aFByaW1pdGl2ZU1hcmsoc3BlYzogR2VuZXJpY1VuaXRTcGVjPEVuY29kaW5nPEZpZWxkPiwgQW55TWFyaz4pOlxuICBzcGVjIGlzIEdlbmVyaWNVbml0U3BlYzxFbmNvZGluZzxGaWVsZD4sIE1hcms+IHtcbiAgICByZXR1cm4gaXNQcmltaXRpdmVNYXJrKHNwZWMubWFyayk7XG59XG5cblxuZnVuY3Rpb24gbm9ybWFsaXplTm9uRmFjZXRVbml0KHNwZWM6IEdlbmVyaWNVbml0U3BlYzxFbmNvZGluZzxGaWVsZD4sIEFueU1hcms+LCBjb25maWc6IENvbmZpZykge1xuICBpZiAoaXNOb25GYWNldFVuaXRTcGVjV2l0aFByaW1pdGl2ZU1hcmsoc3BlYykpIHtcbiAgICAvLyBUT0RPOiB0aG9yb3VnaGx5IHRlc3RcbiAgICBpZiAoaXNSYW5nZWQoc3BlYy5lbmNvZGluZykpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVSYW5nZWRVbml0KHNwZWMpO1xuICAgIH1cblxuICAgIGNvbnN0IG92ZXJsYXlDb25maWc6IE92ZXJsYXlDb25maWcgPSBjb25maWcgJiYgY29uZmlnLm92ZXJsYXk7XG4gICAgY29uc3Qgb3ZlcmxheVdpdGhMaW5lID0gb3ZlcmxheUNvbmZpZyAmJiBzcGVjLm1hcmsgPT09IEFSRUEgJiZcbiAgICAgIGNvbnRhaW5zKFsnbGluZXBvaW50JywgJ2xpbmUnXSwgb3ZlcmxheUNvbmZpZy5hcmVhKTtcbiAgICBjb25zdCBvdmVybGF5V2l0aFBvaW50ID0gb3ZlcmxheUNvbmZpZyAmJiAoXG4gICAgICAob3ZlcmxheUNvbmZpZy5saW5lICYmIHNwZWMubWFyayA9PT0gTElORSkgfHxcbiAgICAgIChvdmVybGF5Q29uZmlnLmFyZWEgPT09ICdsaW5lcG9pbnQnICYmIHNwZWMubWFyayA9PT0gQVJFQSlcbiAgICApO1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGJlY29tZSBhbm90aGVyIGNhc2Ugb2YgY29tcG9zaXRlTWFya1xuICAgIGlmIChvdmVybGF5V2l0aFBvaW50IHx8IG92ZXJsYXlXaXRoTGluZSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZU92ZXJsYXkoc3BlYywgb3ZlcmxheVdpdGhQb2ludCwgb3ZlcmxheVdpdGhMaW5lLCBjb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiBzcGVjOyAvLyBOb3RoaW5nIHRvIG5vcm1hbGl6ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wb3NpdGVNYXJrLm5vcm1hbGl6ZShzcGVjLCBjb25maWcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlZFVuaXQoc3BlYzogVW5pdFNwZWMpIHtcbiAgY29uc3QgaGFzWCA9IGNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBYKTtcbiAgY29uc3QgaGFzWSA9IGNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBZKTtcbiAgY29uc3QgaGFzWDIgPSBjaGFubmVsSGFzRmllbGQoc3BlYy5lbmNvZGluZywgWDIpO1xuICBjb25zdCBoYXNZMiA9IGNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBZMik7XG4gIGlmICgoaGFzWDIgJiYgIWhhc1gpIHx8IChoYXNZMiAmJiAhaGFzWSkpIHtcbiAgICBjb25zdCBub3JtYWxpemVkU3BlYyA9IGR1cGxpY2F0ZShzcGVjKTtcbiAgICBpZiAoaGFzWDIgJiYgIWhhc1gpIHtcbiAgICAgIG5vcm1hbGl6ZWRTcGVjLmVuY29kaW5nLnggPSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy54MjtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy54MjtcbiAgICB9XG4gICAgaWYgKGhhc1kyICYmICFoYXNZKSB7XG4gICAgICBub3JtYWxpemVkU3BlYy5lbmNvZGluZy55ID0gbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueTI7XG4gICAgICBkZWxldGUgbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueTI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTcGVjO1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG5cbi8vIEZJWE1FKCMxODA0KTogcmUtZGVzaWduIHRoaXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU92ZXJsYXkoc3BlYzogVW5pdFNwZWMsIG92ZXJsYXlXaXRoUG9pbnQ6IGJvb2xlYW4sIG92ZXJsYXlXaXRoTGluZTogYm9vbGVhbiwgY29uZmlnOiBDb25maWcpOiBMYXllclNwZWMge1xuICBjb25zdCB7bWFyaywgc2VsZWN0aW9uLCBlbmNvZGluZywgLi4ub3V0ZXJTcGVjfSA9IHNwZWM7XG4gIGNvbnN0IGxheWVyID0gW3ttYXJrLCBlbmNvZGluZ31dO1xuXG4gIC8vIE5lZWQgdG8gY29weSBzdGFjayBjb25maWcgdG8gb3ZlcmxheWVkIGxheWVyXG4gIGNvbnN0IHN0YWNrUHJvcHMgPSBzdGFjayhtYXJrLCBlbmNvZGluZywgY29uZmlnID8gY29uZmlnLnN0YWNrIDogdW5kZWZpbmVkKTtcblxuICBsZXQgb3ZlcmxheUVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmIChzdGFja1Byb3BzKSB7XG4gICAgY29uc3Qge2ZpZWxkQ2hhbm5lbDogc3RhY2tGaWVsZENoYW5uZWwsIG9mZnNldH0gPSBzdGFja1Byb3BzO1xuICAgIG92ZXJsYXlFbmNvZGluZyA9IHtcbiAgICAgIC4uLmVuY29kaW5nLFxuICAgICAgW3N0YWNrRmllbGRDaGFubmVsXToge1xuICAgICAgICAuLi5lbmNvZGluZ1tzdGFja0ZpZWxkQ2hhbm5lbF0sXG4gICAgICAgIC4uLihvZmZzZXQgPyB7c3RhY2s6IG9mZnNldH0gOiB7fSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKG92ZXJsYXlXaXRoTGluZSkge1xuICAgIGxheWVyLnB1c2goe1xuICAgICAgbWFyazoge1xuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIHN0eWxlOiAnbGluZU92ZXJsYXknXG4gICAgICB9LFxuICAgICAgLi4uKHNlbGVjdGlvbiA/IHtzZWxlY3Rpb259IDoge30pLFxuICAgICAgZW5jb2Rpbmc6IG92ZXJsYXlFbmNvZGluZ1xuICAgIH0pO1xuICB9XG4gIGlmIChvdmVybGF5V2l0aFBvaW50KSB7XG4gICAgbGF5ZXIucHVzaCh7XG4gICAgICBtYXJrOiB7XG4gICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgIGZpbGxlZDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6ICdwb2ludE92ZXJsYXknXG4gICAgICB9LFxuICAgICAgLi4uKHNlbGVjdGlvbiA/IHtzZWxlY3Rpb259IDoge30pLFxuICAgICAgZW5jb2Rpbmc6IG92ZXJsYXlFbmNvZGluZ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5vdXRlclNwZWMsXG4gICAgbGF5ZXJcbiAgfTtcbn1cblxuLy8gVE9ETzogYWRkIHZsLnNwZWMudmFsaWRhdGUgJiBtb3ZlIHN0dWZmIGZyb20gdmwudmFsaWRhdGUgdG8gaGVyZVxuXG4vKiBBY2N1bXVsYXRlIG5vbi1kdXBsaWNhdGUgZmllbGREZWZzIGluIGEgZGljdGlvbmFyeSAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShkaWN0OiBhbnksIGZpZWxkRGVmczogRmllbGREZWY8RmllbGQ+W10pOiBhbnkge1xuICBmaWVsZERlZnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZERlZikge1xuICAgIC8vIENvbnNpZGVyIG9ubHkgcHVyZSBmaWVsZERlZiBwcm9wZXJ0aWVzIChpZ25vcmluZyBzY2FsZSwgYXhpcywgbGVnZW5kKVxuICAgIGNvbnN0IHB1cmVGaWVsZERlZiA9IFsnZmllbGQnLCAndHlwZScsICd2YWx1ZScsICd0aW1lVW5pdCcsICdiaW4nLCAnYWdncmVnYXRlJ10ucmVkdWNlKChmLCBrZXkpID0+IHtcbiAgICAgIGlmIChmaWVsZERlZltrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZltrZXldID0gZmllbGREZWZba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBrZXkgPSBoYXNoKHB1cmVGaWVsZERlZik7XG4gICAgZGljdFtrZXldID0gZGljdFtrZXldIHx8IGZpZWxkRGVmO1xuICB9KTtcbiAgcmV0dXJuIGRpY3Q7XG59XG5cbi8qIFJlY3Vyc2l2ZWx5IGdldCBmaWVsZERlZnMgZnJvbSBhIHNwZWMsIHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIGZpZWxkRGVmcyAqL1xuZnVuY3Rpb24gZmllbGREZWZJbmRleDxUPihzcGVjOiBHZW5lcmljU3BlYzxHZW5lcmljVW5pdFNwZWM8YW55LCBhbnk+PiwgZGljdDogRGljdDxGaWVsZERlZjxUPj4gPSB7fSk6IERpY3Q8RmllbGREZWY8VD4+IHtcbiAgLy8gRklYTUUoaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlcy8yMjA3KTogU3VwcG9ydCBmaWVsZERlZkluZGV4IGZvciByZXBlYXRcbiAgaWYgKGlzTGF5ZXJTcGVjKHNwZWMpKSB7XG4gICAgc3BlYy5sYXllci5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGlmIChpc1VuaXRTcGVjKGxheWVyKSkge1xuICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKGxheWVyLmVuY29kaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZERlZkluZGV4KGxheWVyLCBkaWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0ZhY2V0U3BlYyhzcGVjKSkge1xuICAgIGFjY3VtdWxhdGUoZGljdCwgdmxFbmNvZGluZy5maWVsZERlZnMoc3BlYy5mYWNldCkpO1xuICAgIGZpZWxkRGVmSW5kZXgoc3BlYy5zcGVjLCBkaWN0KTtcbiAgfSBlbHNlIGlmIChpc1JlcGVhdFNwZWMoc3BlYykpIHtcbiAgICBmaWVsZERlZkluZGV4KHNwZWMuc3BlYywgZGljdCk7XG4gIH0gZWxzZSBpZiAoaXNDb25jYXRTcGVjKHNwZWMpKSB7XG4gICAgY29uc3QgY2hpbGRTcGVjID0gaXNWQ29uY2F0U3BlYyhzcGVjKSA/IHNwZWMudmNvbmNhdCA6IHNwZWMuaGNvbmNhdDtcbiAgICBjaGlsZFNwZWMuZm9yRWFjaChjaGlsZCA9PiBmaWVsZERlZkluZGV4KGNoaWxkLCBkaWN0KSk7XG4gIH0gZWxzZSB7IC8vIFVuaXQgU3BlY1xuICAgIGFjY3VtdWxhdGUoZGljdCwgdmxFbmNvZGluZy5maWVsZERlZnMoc3BlYy5lbmNvZGluZykpO1xuICB9XG4gIHJldHVybiBkaWN0O1xufVxuXG4vKiBSZXR1cm5zIGFsbCBub24tZHVwbGljYXRlIGZpZWxkRGVmcyBpbiBhIHNwZWMgaW4gYSBmbGF0IGFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gZmllbGREZWZzKHNwZWM6IEdlbmVyaWNTcGVjPEdlbmVyaWNVbml0U3BlYzxhbnksIGFueT4+KTogRmllbGREZWY8YW55PltdIHtcbiAgcmV0dXJuIHZhbHMoZmllbGREZWZJbmRleChzcGVjKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWNrZWQoc3BlYzogVG9wTGV2ZWw8RmFjZXRlZENvbXBvc2l0ZVVuaXRTcGVjPiwgY29uZmlnPzogQ29uZmlnKTogYm9vbGVhbiB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCBzcGVjLmNvbmZpZztcbiAgaWYgKGlzUHJpbWl0aXZlTWFyayhzcGVjLm1hcmspKSB7XG4gICAgcmV0dXJuIHN0YWNrKHNwZWMubWFyaywgc3BlYy5lbmNvZGluZyxcbiAgICAgICAgICAgIGNvbmZpZyA/IGNvbmZpZy5zdGFjayA6IHVuZGVmaW5lZFxuICAgICAgICAgICkgIT09IG51bGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl19